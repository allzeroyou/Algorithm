# 정렬
데이터를 특정한 기준에 따라 순서대로 나열하는 것

## 선택 정렬
처리되지 않은 데이터 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 걸 반복

```
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
    min_index = i # 가장 작은 원소의 인덱스
    for j in range(i+1, len(array)): # 선형 탐색 수행, 가장 작은 원소 찾기
        if array[min_index] > array[j]: # 만약 j보다 가장 작은 원소의 인덱스가 크다면
            min_index = j               # 가장 작은 원소의 인덱스에 j를 대입
    array[i], array[min_index] = array[min_index], array[i] # 스와프, 파이썬에서는 별도의 라이브러리 필요없이 변수 스와핑 가능
print(array)
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

## 삽입 정렬
처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입
선택 정렬에 비해 구현 난이도는 높지만, 일반적으로 더 효율적으로 동작
```
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(1, len(array)):
    for j in range(i, 0, -1): # 인덱스 i부터 1까지 1씩 감소하며 반복
        if array[j] < array[j-1]: # 한 칸씩 왼쪽으로 이동
            array[j], array[j-1] = array[j-1], array[j]
        else: # 자기보다 작은 데이터를 만나면 그 위치에서 멈충
            break
print(array)
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

## 퀵 정렬
기준 데이터를 설정, 그 기준보다 큰 데이터/ 작은 데이터의 위치 바꿈
병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러의 근간이 되는 알고리즘임

가장 기본적인 퀵 정렬은 가장 맨 앞 데이터를 기준 데이터로 삼음

평균적으로 O(NlogN)의 시간복잡도를 가짐
하지만 최악의 경우 O(N^2)의 시간 복잡도를 가짐

> 코드 내용이 길어서, 가독성을 위해 code 따로 작성

## 계수 정렬
특정한 조건이 부합할 때만 사용가능, but 매우 빠르게 동작
계수 정렬은 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을때 사용 가능
데이터의 개수 N, 데이터(양수)중 최댓값이 K일때 최악의 경우에도 수행시간 O(N+K) 보장

> 코드 내용이 길어서, 가독성을 위해 code 따로 작성


## 정렬 알고리즘 비교하기
선택정렬: 평균 시간복잡도 O(N^2)
삽입정렬: 평균 시간복잡도 O(N^2)
퀵 정렬: 평균 시간복잡도 O(NlogN)
계수 정렬: 평균 시간복잡도 O(N+K)

표준 정렬 라이브러리는 최악의 경우에도 O(NlogN)을 보장하도록 설계됨
