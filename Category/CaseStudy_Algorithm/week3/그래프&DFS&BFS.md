# 그래프

정점과 정점 간의 관계를 표시하는 간선으로 구성된 자료

e.g.

지도, 내비게이션

SNS, 메신저(친구 관계)

문제에서 정점의 개수를 주어지는데, 약어로 v or n을 사용

관련 용어
- **방향** Direction
    - 무방향 그래프(= **양방향 = 순환 그래프**): 방향 X
    - 방향 그래프: 방향 O
- **순환** Cycle
    - 순환 그래프 Cyclic Graph: 그래프에서 한 군데라도 순환 O
        (이때, **순환은 어떤 한 노드에서 시작해서 다른 노드로 갔다가 처음 출발했던 정점으로 돌아올 수 있음을 의미**)
    - 비순환 그래프 Acyclic Graph
- **연결요소**
방향성 비순환 그래프 DAG(Directed Acyclic Graph)
e.g.

`암호화폐`
→block chain을 이용해 만들어진 기술임

블록들이 chain을 이룬 상태를 일컫음

하나하나의 블록들이 체결 기록을 가지고 있음

일종의 송금을 할 때마다 체결기록을 남아서 블록을 이뤄 chain구조로 이뤄짐

시간은 일방향이니까, 시간의 방향성을 띄고

순환은 절대일어나지 않음

`Git Branch`
깃 브랜치 역시 DAG중 하나임

커밋메시지와 함께 코드를 커밋함 →시간에 따라 찍힘

시간에 따라 일방향 + 미래에서 과거로 돌아갈 수 없음

## 그래프를 코드로 나타내는 방법

### 1. 인접 행렬****
2차원 배열을 만들어서 표현 가능
### 2. 인접 리스트****(Adjacency List)****
연결리스트들의 배열
Array of Linked List

연결리스트를 필요로 함
→ 파이썬에서는 2차원 `동적 배열로` 구현함

그래프 문제는 둘 중 하나를 골라서 풀어야 됨
그럼 어느걸 쓸까?
어떤 경우에는 인접행렬이 나은경우가 있고 인접리스트가 나은 경우가 있음

e.g.
만약 0번에서 2번으로 가는 간선이 있나? 조회를 해야할때

인접행렬에서는 a[0][2]==1인지 확인함

배열은 조회 속도가 빠르다는 장점이 있음 = O(1)

→ 왜? → 임의접근이 가능하므로!(=시작점에서 조회하고자 하는 인덱스인, 바로 그 위치로 jump! 가능함)

연결리스트(배열과 정반대의 성격)는 조회 속도가 느림= O(N)

- **인접 행렬은 시간복잡도가 더 빠름(속도)**
- 차지하고 있는 메모리양은 **인접리스트가 더 적음(메모리양)**

    인접행렬은 N^2만큼 메모리 할당해야 함, 인접 리스트는 간선이 적으면 적을수록 메모리를 적게 차지함.


그래서 어떨때 뭘 사용해?

간선의 수가 최대 간선의 수에 가까운 그래프(밀집그래프(dense): 간선이 엄청나게 많은 그래프임) → `인접행렬 사용`이 유리

희소그래프: 간선이 얼마없는 그래프 → `인접리스트 사용`이 유리

→ 백준 실버 수준 문제에서는 인접행렬, 인접리스트 2개중 아무거나 사용해도  ok(골드 수준에서는 두개 중 하나를 올바르게 사용해야 함)

# DFS(Depth First Search)

**깊이 우선 탐색**

완전탐색 알고리즘임.

최악의 경우, DFS, BFS 모두 완전탐색 알고리즘인건 동일하나 먼저 훑어보는 정보가 다름

**스택** or **재귀**를 사용해서 구현함

한쪽으로 **깊~게 바닥으로** **파고들어가는 모습**을 확인 → **깊이 우선 탐색**

## DFS 의사코드

```python
방문_배열 선언
방문_배열[시작_지점] = true

DFS(시작_지점) # start

함수 DFS(현재지점){
	// 필요한 연산 처리 후
	for 다음_지점 in 1 ~ N{    # 인접 행렬 떠올리기(1이 들어있는지 확인)
		if 정점_연결_확인(다음_지점) == false{    # a[1][i] == 1 인지 확인
			continue
		}
		if 방문_배열[다음_지점]{      # 방문 했다면 넘어감
			continue
		}
		방문_배열[다음_지점] = true
		DFS(다음_지점)
	}
}
```

그래프 코드 구현시 방문 체크가 필수임(내가 방문했는지 안했는지)

# BFS(Breadth First Search)
너비 우선 탐색

**큐**를 사용해서 구현

잔잔한 물가에 돌을 넣지만 점점 넓어지는 파동이 일듯,

BFS도 시작노드에서 시작해서 탐색을 할수록 점점 넓어지는 형태를 띈다. → 너비 우선 탐색

큐에서 하나 빼서 살펴보고, 다음 갈 노드 살펴보고 큐에 대입
→ 시작점 노드에서부터 거리를 1씩 늘려가면서 사용 가능

## BFS 의사코드

```python
함수 BFS(현재지점){
	방문_배열 선언
	방문_배열[시작_지점]=true
	큐 선언
	큐.push(시작_지점)

	while 큐가 비어있지 않으면{
		현재_지점 = 큐.pop()

		// 필요한 연산 처리 후

		for 다음_지점 in 1 ~ N{
			if 정점_연결_확인(다음_지점) == false{
				continue
		}
		if 방문_배열[다음_지점]{
				continue
		}
		방문_배열[다음_지점] = true
		큐.push(다음_지점)
		}
	}
}
```

그래프 코드 구현시 방문 체크가 필수임(내가 방문했는지 안했는지)

DFS & BFS

- 공통점
    - 완전 탐색
    - 모든 경우의 수를 살펴보는 거라면 둘중 아무거나 사용 ok
- 차이점
    - **BFS**에서 찾은 노드는 **최단 거리의 노드**임을 보장함

# 길찾기 문제

- ➡️⬇️⬅️⬆️ 4방향이 많다(동서남북)
- 범위 체크 + 방문 체크 필요

dfs

```python
dy = (0, 1, 0, -1) # 상대좌표값
dx = (1, 0, -1, 0)

chk = [[False]*100 for _ in range(100) ] # 방문 체크(100*100)

def is_valid_coord(y, x): # 범위 체크
	return 0 <= y < 100 and 0 <= x < 100 # y좌표가 100*100 내 유효한 좌표인지 확인

def dfs(y, x):
	for i in range(4):  # 동서남북(4방향)
		ny= y+dy[i] # next y, x
		nx= x+dx[i]
		if is_valid_coord(ny, nx) and not chk[ny][nx]:
			chk[ny][nx] = True
			dfs(ny, nx) # 재귀 호출

chk[sy][sx] = True # start y, x
dfs(sy, sx)
```

dy, dx 배열 안쓰고도 구현은 가능하되, 코드가 길어지고 코딩실수 날 가능성 있음

기본적인 부분은 모듈화 →프로그래밍 철학

bfs

```python
dy = (0, 1, 0, -1)
dx = (1, 0, -1, 0)

def is_valid_coord(y, x):
	return 0<= y < 100 and 0 <= x < 100

def bfs(sy, sx): # start y, x
	chk = [[False]*100 for _ in range(100)]
	chk[sy][sx] = True
	q = deque()
	q.append((sy, sx))
	while q:
		y, x = q.popleft()
		for i in range(4):
			ny = y+dy[i] # next y, x
			nx = x+dx[i]
			if is_valid_coord[ny, nx] and not chk[ny][nx]:
					chk[ny][nx] = True
					q.append((ny, nx)) # 큐 삽입
```

# 백 트래킹

퇴각검색

→ 알고리즘 설계 기법

- 완전 탐색 시 볼 필요가 없는 경우들을 줄여주는 알고리즘 기법
- 백트래킹은 가지치기를 통해 탐색 경우의 수를 **줄임**
    - 최악의 경우, 모든 경우를 다 살필 수 있는 것을 대비
    - 가망성이 없으면 가지 않음
- DFS & BFS 둘 다 백 트래킹을 통해 경우의 수를 줄여 줄 수 있음
    - 보통은 DFS 백트래킹 자주 사용